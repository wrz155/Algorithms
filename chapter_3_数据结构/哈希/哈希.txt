哈希表在计算机科学中应用广泛。比如在版本控制git中就用到了hash：
在git中，文件内容为键值，并用SHA算法作为hash function，
将文件内容对应为固定长度的字符串(hash值)。
如果文件内容发生变化，那么所对应的字符串就会发生变化。git通过比较较短的hash值，就可以知道文件内容是否发生变动。
再比如计算机的登陆密码，一般是一串字符。然而，为了安全起见，计算机不会直接保存该字符串，而是保存该字符串的hash值(使用MD5、SHA或者其他算法作为hash函数)。
当用户下次登陆的时候，输入密码字符串。如果该密码字符串的hash值与保存的hash值一致，那么就认为用户输入了正确的密码。
这样，就算黑客闯入了数据库中的密码记录，他能看到的也只是密码的hash值。
上面所使用的hash函数有很好的单向性：很难从hash值去推测键值。因此，黑客无法获知用户的密码。
注意，hash只要求从A到B的对应为一个映射，它并没有限定该对应关系为一一映射。
因此会有这样的可能：两个不同的键值对应同一个hash值。
这种情况叫做hash碰撞(hash collision)。
比如网络协议中的checksum就可能出现这种状况，即所要校验的内容与原文并不同，但与原文生成的checksum(hash值)相同。
再比如，MD5算法常用来计算密码的hash值。已经有实验表明，MD5算法有可能发生碰撞，也就是不同的明文密码生成相同的hash值，这将给系统带来很大的安全漏洞。


1）好的hash函数，分布均匀，冲突少
2）冲突解决：链地址表
				冲突位置放一个指针，指向一个链表，这样所有相同位置的元素都放在这个链表中，
				链表采用头插法，这样新加入的元素很可能再次被访问，放到头就不用遍历了。
3）当存放的值越来越多，需要rehash，关键在于何时rehash？
4）装载因子，用来表示hash表的装满程度，这里也代表链表的平均长度，当装载因子到阈值之后就可以rehash了。