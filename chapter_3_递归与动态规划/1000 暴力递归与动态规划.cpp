递归，递推，迭代的区别
递归：
1、程序调用自身的编程技巧称为递归,是函数自己调用自己。
2、使用递归要注意的有两点:
	1)递归就是在过程或函数里面调用自身;
	2)在使用递归时, 必须有一个明确的递归结束条件, 称为递归出口.
3、递归分为两个阶段:
	1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;
	2)回归:当获得最简单的情况后, 逐步返回, 依次得到复杂的解.
4、优点：代码更简洁清晰，可读性更好递归可读性好这一点，对于初学者可能会反对。
	实际上递归的代码更清晰，但是从学习的角度要理解递归真正发生的什么，是如何调用的，调用层次和路线，
	调用堆栈中保存了什么，可能是不容易。但是不可否认递归的代码更简洁。
5、缺点：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多。而且，如果递归深度太大，可能会造成栈溢出
	//递归法求第n个数的斐波那契数列
	long factorial(int n)
	{
		if(n <= 2)
			return 1;
		if(n > 1)
			return factorial(n - 2) +factorial(n - 1);
	}
	//递归法计算n的阶乘
	long factorial(int n)
	{
		if (n <= 0)
			return 1;
		else
			return n*factorial(n - 1);
	}
迭代：
迭代:
1、利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,
迭代就是A不停的调用B
2、优点：1）迭代效率高，运行时间只因循环次数增加而增加；
         2）没什么额外开销，空间上也没有什么增加；
3、缺点：1） 不容易理解；    2） 代码不如递归简洁；    3） 编写复杂问题时困难。
注意： 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出
//迭代法计算n的阶乘
	long factorial(int n)
	{
		int result = 1;
		while (n > 1){
			result *= n;
			n -= 1;
		}
		return result;
	}

递推：没有回溯的那一部分
1、递推算法是一种简单的算法，即通过已知条件，利用特定关系得出中间推论，
直至得到结果的算法。递推算法分为顺推和逆推两种。
2、相对于递归算法,递推算法免除了数据进出栈的过程，也就是说,不需要函数不
断的向边界值靠拢,而直接从边界出发,直到求出函数值。
	#define size 20
	int main()
	{//循环法
		int arr[size];
		arr[0] = 0;
		arr[1] = 1;
		for (int i = 0; i <= size; i++){
			if (i>1)
				arr[i] = arr[i - 2] + arr[i - 1];
			//递推算法
			printf("factorial[%d]=%d\n", i, arr[i]);
		}
		system("pause");
		return 0;
	}
	
递推和迭代的区别：
	递推往往设置数组，而迭代只要设置几个简单变量即可
	递推过程中保留了中间数据而迭代是不保留的。























介绍递归和动态规划
暴力递归：	
	1，把问题转化为规模缩小了的同类问题的子问题 
	2，有明确的不需要继续进行递归的条件(base case) 
	3，有当得到了子问题的结果之后的决策过程 
	4，不记录每一个子问题的解
动态规划	
	1，从暴力递归中来 
	2，将每一个子问题的解记录下来，避免重复计算 
	3，把暴力递归的过程，抽象成了状态表达 
	4，并且存在化简状态表达，使其更加简洁的可能
	
另一种表述：
	动态规划:	1）边界				（base case）
				2）最优子结构		例：F(n) = F(n-1)+F(n-2)	F(n-1)和F(n-2)	就是最优子结构
				3）状态转移方程		利用最优子结构去构造状态转移方程	

	第一步：暴力递归：	时间复杂度O(n^2)
	第二步：备忘录算法：时间复杂度O(n),空间复杂度O(n)
	第三步：动态规划：	时间复杂度O(n),空间复杂度O(1)